// Copyright 2010-2011 Michel Kraemer
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package de.undercouch.bson4jackson

import java.io.IOException
import java.io.OutputStream
import java.math.BigDecimal
import java.math.BigInteger
import java.nio.ByteOrder
import java.nio.CharBuffer
import java.util.ArrayDeque
import java.util.Deque
import org.codehaus.jackson.Base64Variant
import org.codehaus.jackson.JsonGenerationException
import org.codehaus.jackson.JsonGenerator
import org.codehaus.jackson.impl.JsonGeneratorBase
import org.codehaus.jackson.impl.JsonWriteContext
import de.undercouch.bson4jackson.io.DynamicOutputBuffer

/**
 * Writes BSON code to the provided output stream
 * @author Michel Kraemer
 */
object BsonGenerator {

  /**
   * Defines toggable features
   */
  final object Feature {
    /**
     * <p>Enables streaming by setting the document's total
     * number of bytes in the header to 0. This allows the generator
     * to flush the output buffer from time to time. Otherwise the
     * generator would have to buffer the whole file to be able to
     * calculate the total number of bytes.</p>
     * <p><b>ATTENTION:</b> By enabling this feature, the BSON document
     * generated by this class will not be compatible to the
     * specification! However, if you know what you are doing and
     * if you know that the document will be read by a parser that
     * ignores the total number of bytes anyway (like {@link BsonParser}
     * or <code>org.bson.BSONDecoder</code> from the MongoDB Java Driver
     * do) then this feature will be very useful.</p>
     */
    final val ENABLE_STREAMING = new Feature("ENABLE_STREAMING",0)
  }

  final class Feature(name:String,ord:Int) extends java.lang.Enum[Feature](name,ord){
    /**
     * @return the bit mask that identifies this feature
     */
    def getMask: Int = 1 << ordinal
  }

  /**
   * A structure describing the document currently being generated
   * @author Michel Kraemer
   *
   * Creates a new DocumentInfo object
   * @param headerPos the position of the document's header
   * in the output buffer
   * @param array true if the document is an array
   */
  case class DocumentInfo(var headerPos:Int,var currentArrayPos:Int) {
    def this(headerPos: Int, array: Boolean) {
      this (headerPos,(if (array) 0 else -1))
    }
  }
}

/**
 * Creates a new generator
 * @param jsonFeatures bit flag composed of bits that indicate which
 * { @link org.codehaus.jackson.JsonGenerator.Feature}s are enabled.
 * @param bsonFeatures bit flag composed of bits that indicate which
 * { @link Feature}s are enabled.
 * @param out the output stream to write to
 */
class BsonGenerator(
  jsonFeatures: Int,val _bsonFeatures: Int,val _out:OutputStream
) extends JsonGeneratorBase(jsonFeatures,null) {

  import BsonGenerator._

  locally{
    if (isEnabled(Feature.ENABLE_STREAMING)) {
      _buffer.setReuseBuffersCount(2)
    }
  }

  /**
   * Checks if a generator feature is enabled
   * @param f the feature
   * @return true if the given feature is enabled
   */
  protected def isEnabled(f: BsonGenerator.Feature): Boolean = {
    (_bsonFeatures & f.getMask) != 0
  }

  /**
   * @return true if the generator is currently processing an array
   */
  protected def isArray: Boolean = {
    (if (_documents.isEmpty) false else _documents.peek.currentArrayPos >= 0)
  }

  /**
   * Retrieves and then increases the current position in the array
   * currently being generated
   * @return the position (before it has been increased) or -1 if
   * the current document is not an array
   */
  protected def getAndIncCurrentArrayPos: Int = {
    if (_documents.isEmpty) {
      -1
    }else{
      val di = _documents.peek
      val r = di.currentArrayPos
      di.currentArrayPos += 1
      r
    }
  }

  /**
   * Reserves bytes for the BSON document header
   */
  protected def reserveHeader: Unit = {
    _buffer.putInt(0)
  }

  /**
   * Writes the BSON document header to the output buffer at the
   * given position. Does not increase the buffer's write position.
   * @param pos the position where to write the header
   */
  protected def putHeader(pos: Int): Unit = {
    _buffer.putInt(pos, _buffer.size - pos)
  }

  override def flush: Unit = {
    _out.flush
  }

  override protected def _releaseBuffers: Unit = {
    _buffer.clear
  }

  override def close: Unit = {
    if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {
      while (!_documents.isEmpty) {
        writeEndObject()
      }
    }
    _buffer.writeTo(_out)
    _buffer.clear()
    _out.flush()
    if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {
      _out.close
    }
    super.close
  }

  override def writeStartArray: Unit = {
    _verifyValueWrite("start an array")
    _writeContext = _writeContext.createChildArrayContext
    _writeStartObject(true)
  }

  override def writeEndArray: Unit = {
    if (!_writeContext.inArray) {
      _reportError("Current context not an ARRAY but " + _writeContext.getTypeDesc)
    }
    writeEndObjectInternal()
    _writeContext = _writeContext.getParent
  }

  override def writeStartObject: Unit = {
    _verifyValueWrite("start an object")
    _writeContext = _writeContext.createChildObjectContext
    _writeStartObject(false)
  }

  /**
   * Creates a new embedded document or array
   * @param array true if the embedded object is an array
   * @throws IOException if the document could not be created
   */
  protected def _writeStartObject(array: Boolean): Unit = {
    _writeArrayFieldNameIfNeeded()
    if (!_documents.isEmpty) {
      _buffer.putByte(_typeMarker, (if (array) BsonConstants.TYPE_ARRAY else BsonConstants.TYPE_DOCUMENT))
    }
    _documents.push(new BsonGenerator.DocumentInfo(_buffer.size, array))
    reserveHeader
  }

  override def writeEndObject(): Unit = {
    if (!_writeContext.inObject) {
      _reportError("Current context not an object but " + _writeContext.getTypeDesc)
    }
    _writeContext = _writeContext.getParent
    writeEndObjectInternal()
  }

  private def writeEndObjectInternal(): Unit = {
    if (!_documents.isEmpty) {
      _buffer.putByte(BsonConstants.TYPE_END)
      val info = _documents.pop
      if (!isEnabled(Feature.ENABLE_STREAMING)) {
        putHeader(info.headerPos)
      }
    }
  }

  /**
   * If the generator is currently processing an array, this method writes
   * the field name of the current element (which is just the position of the
   * element in the array)
   * @throws IOException if the field name could not be written
   */
  protected def _writeArrayFieldNameIfNeeded(): Unit = {
    if (isArray) {
      val p = getAndIncCurrentArrayPos
      _writeFieldName(String.valueOf(p))
    }
  }

  override def writeFieldName(name: String): Unit = {
    val status = _writeContext.writeFieldName(name)
    if (status == JsonWriteContext.STATUS_EXPECT_VALUE) {
      _reportError("Can not write a field name, expecting a value")
    }
    _writeFieldName(name)
  }

  private def _writeFieldName(name: String): Unit = {
    _typeMarker = _buffer.size
    _buffer.putByte(0.asInstanceOf[Byte])
    _buffer.putUTF8(name)
    _buffer.putByte(BsonConstants.END_OF_STRING)
  }

  override protected def _verifyValueWrite(typeMsg: String): Unit = {
    val status = _writeContext.writeValue
    if (status == JsonWriteContext.STATUS_EXPECT_NAME) {
      _reportError("Can not " + typeMsg + ", expecting field name")
    }
  }

  /**
   * Tries to flush the output buffer if streaming is enabled. This
   * method is a no-op if streaming is disabled.
   * @throws IOException if flushing failed
   */
  protected def flushBuffer(): Unit = {
    if (isEnabled(Feature.ENABLE_STREAMING)) {
      _buffer.flushTo(_out)
    }
  }

  override def writeString(text: String): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write string")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_STRING)
    val p = _buffer.size
    _buffer.putInt(0)
    val l = _buffer.putUTF8(text)
    _buffer.putByte(BsonConstants.END_OF_STRING)
    _buffer.putInt(p, l + 1)
    flushBuffer
  }

  override def writeString(text: Array[Char], offset: Int, len: Int): Unit = {
    writeString(new String(text, offset, len))
  }

  override def writeRaw(text: String): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write raw string")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_BINARY)
    _buffer.putInt(text.length * 2)
    _buffer.putByte(BsonConstants.SUBTYPE_BINARY)
    _buffer.putString(text)
    flushBuffer
  }

  override def writeRaw(text: String, offset: Int, len: Int): Unit = {
    writeRaw(text.substring(offset, len))
  }

  override def writeRaw(text: Array[Char], offset: Int, len: Int): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write raw string")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_BINARY)
    _buffer.putInt(text.length * 2)
    _buffer.putByte(BsonConstants.SUBTYPE_BINARY)
    _buffer.putString(CharBuffer.wrap(text))
    flushBuffer
  }

  override def writeRaw(c: Char): Unit = {
    writeRaw(Array[Char](c), 0, 1)
  }

  override def writeBinary(b64variant: Base64Variant, data: Array[Byte], offset: Int, len: Int): Unit = {
    writeBinary(b64variant, BsonConstants.SUBTYPE_BINARY, data, offset, len)
  }

  /**
   * Similar to {@link #writeBinary(Base64Variant, byte, byte[], int, int)},
   * but with the possibility to specify a binary subtype (see
   * {@link BsonConstants}).
   * @param b64variant base64 variant to use (will be ignored for BSON)
   * @param subType the binary subtype
   * @param data the binary data to write
   * @param offset the offset of the first byte to write
   * @param len the number of bytes to write
   * @throws IOException if the binary data could not be written
   */
  def writeBinary(b64variant: Base64Variant, subType: Byte, data: Array[Byte], o: Int, len: Int): Unit = {
    var offset = o
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write binary")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_BINARY)
    _buffer.putInt(len)
    _buffer.putByte(subType)
    var end = offset + len
    if (end > data.length) {
      end = data.length
    }
    while (offset < end) {
      _buffer.putByte(data(offset))
      offset += 1
    }
    flushBuffer()
  }

  override def writeNumber(v: Int): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write number")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_INT32)
    _buffer.putInt(v)
    flushBuffer
  }

  override def writeNumber(v: Long): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write number")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_INT64)
    _buffer.putLong(v)
    flushBuffer
  }

  override def writeNumber(v: BigInteger): Unit = {
    val bl = v.bitLength
    if (bl < 32) {
      writeNumber(v.intValue)
    }
    else if (bl < 64) {
      writeNumber(v.longValue)
    }
    else {
      writeString(v.toString)
    }
  }

  override def writeNumber(d: Double): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write number")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_DOUBLE)
    _buffer.putDouble(d)
    flushBuffer
  }

  override def writeNumber(f: Float): Unit = {
    writeNumber(f.asInstanceOf[Double])
  }

  override def writeNumber(dec: BigDecimal): Unit = {
    val f = dec.floatValue
    if (!java.lang.Float.isInfinite(f)) {
      writeNumber(f)
    }
    else {
      val d = dec.doubleValue
      if (!java.lang.Double.isInfinite(d)) {
        writeNumber(d)
      }
      else {
        writeString(dec.toString)
      }
    }
  }

  override def writeNumber(encodedValue: String): Unit = {
    writeString(encodedValue)
  }

  override def writeBoolean(state: Boolean): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write boolean")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_BOOLEAN)
    _buffer.putByte((if (state) 1 else 0).asInstanceOf[Byte])
    flushBuffer
  }

  override def writeNull: Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write null")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_NULL)
    flushBuffer
  }

  override def writeRawUTF8String(text: Array[Byte], offset: Int, length: Int): Unit = {
    _writeArrayFieldNameIfNeeded()
    _verifyValueWrite("write raw utf8 string")
    _buffer.putByte(_typeMarker, BsonConstants.TYPE_STRING)
    val p = _buffer.size
    _buffer.putInt(0)

    var i = offset
    while (i < length) {
      _buffer.putByte(text(i))
      i += 1
    }
    _buffer.putByte(BsonConstants.END_OF_STRING)
    _buffer.putInt(p, length)
    flushBuffer()
  }

  override def writeUTF8String(text: Array[Byte], offset: Int, length: Int): Unit = {
    writeRawUTF8String(text, offset, length)
  }

  /**
   * Since a BSON document's header must include the size of the whole document
   * in bytes, we have to buffer the whole document first, before we can
   * write it to the output stream. BSON specifies LITTLE_ENDIAN for all tokens.
   */
  protected final val _buffer = new DynamicOutputBuffer(ByteOrder.LITTLE_ENDIAN)
  /**
   * Saves the position of the type marker for the object currently begin written
   */
  protected var _typeMarker: Int = 0
  /**
   * Saves information about documents (the main document and embedded ones)
   */
  protected val _documents = new ArrayDeque[DocumentInfo]()
}
